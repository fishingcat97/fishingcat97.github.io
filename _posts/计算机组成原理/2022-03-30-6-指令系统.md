---
redirect_from: /_posts/2022-03-30-6-指令系统.md
title: 第六章 指令系统
tags: 计算机组成原理
---

## 6.1 机器指令

### 6.1.1 指令的一般格式

指令由操作码和地址码两部分组成

![指令的一般格式](/assets/image/计算机组成原理/指令系统/指令的一般格式.jpg)

#### **一、操作码**

操作码用来指明机器做什么操作。通常,其位数反映了机器的操作种类,也即机器允许的指令条数,如操作码占7位,则该机器最多包含128条指令

操作码的长度可以是固定的,也可以是变化的。前者将操作码集中放在指令字的一个字段内，这种格式便于硬件设计,指令译码时间短,广泛用于字长较长的、大中型计算机和超级小型计算机以及RISC；
操作码长度不固定的指令,其操作码分散在指令字的不同字段中。这种格式可有效地压缩操作码的平均长度,在字长较短的微机中被广泛采用。

- **扩展操作码技术**

扩展操作码技术使操作码的长度随地址数的减少而增加,不同地址数的指令可以具有不同长度的操作码,从而在满足需要的前提下,有效地缩短指令字长。


![扩展操作码1](/assets/image/计算机组成原理/指令系统/扩展操作码1.jpg)

图中指令字长为16位,其中4位为基本操作码字段OP,另有三个4位长的地址字段为$A_{1}$、$A_{2}$、$A_{3}$4位基本操作码若全部用于三地址指令,则有16条。图中所示是三地址指令15条,二地址指令15条,一地址指令15条,零地址指令16条，共61条。

这种方法采用操作码的前几位作为标志，从而确定操作码的位数。三地址指令操作码每减少一种最多可多构成$2^{4}$种二地址指令;二地址指令操作码每减少一种最多可多构成$2^{4}$种一地址指令。

一般使用短操作码表示高频指令，长操作码表示低频指令。操作码越短，比较次数越少，速度越快。


#### **二、地址码**

> 地址码用来指出该指令的源操作数的地址(一个或两个)、结果的地址以及下一条指令的地址。这里的“地址”可以是主存的地址,也可以是寄存器的地址,甚至可以是I/O设备的地址

**设指令字长为32位，操作码固定为8位**

- **四地址**

![四地址](/assets/image/计算机组成原理/指令系统/四地址.jpg)

- **三地址**

四地址最大寻址范围为$2^{6}=64$,若使用PC代替$A_{4}$保存下一条指令的地址，则变为三地址指令，每个地址为8位，最大寻址范围位$2^{8}=256$

![三地址](/assets/image/计算机组成原理/指令系统/三地址.jpg)

- **二地址**

若使用$A_{1}$或$A_{2}$代替$A_{3}$，将操作结果写入$A_{1}$或$A_{2}$中，则变为二地址，每个地址为12位，最大寻址范围位$2^{12}=4K$

![二地址](/assets/image/计算机组成原理/指令系统/二地址.jpg)

若将结果存放于ACC寄存器中，则只会访存三次

- **一地址**

若使用ACC寄存器代替$A_{1}$或$A_{2}$，将操作结果写入ACC中，则变为一地址，每个地址为24位，最大寻址范围位$2^{24}=16M$，并且只产生两次访存

![一地址](/assets/image/计算机组成原理/指令系统/一地址.jpg)

- **零地址**

零地址指令在指令字中无地址码,例如进栈(PUSH)、出栈(POP)这类指令,其操作数的地址隐含在堆栈指针SP中

### 6.1.2 指令字长

![指令字长](/assets/image/计算机组成原理/指令系统/指令字长.jpg)

## 6.2 操作数类型和操作类型

### 6.2.1 操作数类型

机器中常见的操作数类型有:地址、数字、字符、逻辑数据等。

- 地址：地址实际上也可看作是一种数据,在许多情况下要计算操作数的地址。这时,地址可被认为是一个无符号的整数
- 数字：定点数、浮点数、十进制数
- 字符：ASCII
- 逻辑数据：计算机除了作算术运算外,有时还需作逻辑运算,此时n个0和1的组合不是被看作算术数字,而是看作逻辑数。

### 6.2.2 数据在存储器中的存放方式

- **大端存储与小端存储**

![大端存储与小端存储](/assets/image/计算机组成原理/指令系统/大端存储与小端存储.jpg)

- **数据在存储器中的存放方式**

字节编址，数据在存储器中的存放方式（假设存储字长64 位，机器字长32位）

(1) 从任意位置开始存储

![从任意位置开始存储](/assets/image/计算机组成原理/指令系统/从任意位置开始存储.jpg)

优点：不浪费存储资源  

缺点：除了访问一个字节之外，访问其它任何类型的数据， 都可能花费两个存储周期的时间。读写控制比较复杂。

(2) 从一个存储字的起始位置开始访问

![从一个存储字的起始位置开始访问](/assets/image/计算机组成原理/指令系统/从一个存储字的起始位置开始访问.jpg)

优点：无论访问何种类型的数据，在一个周期内均可完成，读写控制简单。

缺点：浪费了存储资源

(3) 边界对准方式——从地址的整数倍位置开始访问

![从地址的整数倍位置开始访问](/assets/image/计算机组成原理/指令系统/从地址的整数倍位置开始访问.jpg)

数据存放的起始地址是数据长度（按照编址单位进行计算）的整数倍，比如一个字节可以随意存储；半字是两个字节，需要存放在起始位置是2的整数倍的位置；字存放在起始位置是4的整数倍的位置；双字存放在起始位置是8的整数倍的位置

本方案是前两个方案的折衷，在一个周期内可以完成存储访问，空间浪费也不太严重。

### 6.2.3 操作类型

- 数据传送

数据传送包括寄存器与寄存器、寄存器与存储单元、存储单元与存储单元之间的传送。如从源到目的之间的传送、对存储器读(LOAD)和写( STORE)、交换源和目的的内容、置1、清0、进栈、出栈等。

![数据传送](/assets/image/计算机组成原理/指令系统/数据传送.jpg)

- 算术逻辑操作

算术操作：加、减、乘、除、增 1、减 1、求补、浮点运算、十进制运算   
逻辑操作：与、或、非、异或、位操作、位测试、位清除、位求反

如 8086 ADD  SUB  MUL  DIV  INC  DEC  CMP  NEG
       AAA  AAS  AAM  AAD
       AND   OR   NOT   XOR   TEST

- 移位操作

算术移位  
逻辑移位  
循环移位  

- 转移

(1)无条件转移

无条件转移不受任何条件约束,可直接把程序转移到下一条需执行指令的地址。如JMP   X其功能是将指令地址无条件转至X。

(2)条件转移

条件转移是根据当前指令的执行结果,来决定是否需转移。若条件满足则转移;若条件不满足,则继续按顺序执行。

如：  
结果为零转    （Z = 1）  JZ  
结果溢出转    （O = 1）JO   
结果有进位转（C = 1）JC  
跳过一条指令  SKP  

(3)调用和返回

在编写程序时,有些具有特定功能的程序段会被反复使用。为避免重复编写,可将这些程序段设定为独立子程序,当需要执行某子程序时,只需用子程序调用指令即可。

(4)陷阱（Trap）与陷阱指令 

陷阱其实是一种意外事故的中断。一般不提供给用户直接使用，在出现事故时，由 CPU 自动产生并执行（隐指令）

(5)输入输出

输入：&emsp;端口中的内容 -----→CPU 的寄存器   
如：IN&emsp;AL, n  &emsp;&emsp;  IN&emsp;AX, DX
 
输出：&emsp;CPU 的寄存器 -----→端口中的内容  
如：OUT&emsp;n, AL  &emsp;&emsp;  OUT&emsp;DX, AX

## 6.3 寻址方式

### 6.3.1 指令寻址

顺序寻址: ( PC ) + 1 ————> PC，这里的1根据指令大小调整

跳跃寻址: 由转移指令指出

### 6.3.2 数据寻址

形式地址(A)：指令字中的地址  
有效地址(EA)：操作数的真实地址  
约定：指令字长 = 存储字长 = 机器字长

![一地址指令格式](/assets/image/计算机组成原理/指令系统/一地址指令格式.jpg)

#### **一、立即寻址**

立即寻址的特点是操作数本身设在指令字内,即形式地址A不是操作数的地址,而是操作数本身,又称之为立即数。数据是采用补码形式存放的。

![立即寻址](/assets/image/计算机组成原理/指令系统/立即寻址.jpg)

- 指令执行阶段可以不访存直接获得数据  
- A的位数限制了立即数的范围

#### **二、直接寻址**

直接寻址的特点是,指令字中的形式地址A就是操作数的真实地址EA，即EA=A

![直接寻址](/assets/image/计算机组成原理/指令系统/直接寻址.jpg)

- 执行阶段访问一次存储器
- A的位数决定了该指令操作数的寻址范围
- 操作数的地址不易修改（必须修改A）

#### **三、隐含寻址**

隐含寻址是指指令字中不明显地给出操作数的地址,其操作数的地址隐含在操作码或某个寄存器中。

例如,一地址格式的加法指令只给出一个操作数的地址,另一个操作数隐含在累加器ACC中,这样累加器ACC成了另一个数的地址。

![隐含寻址](/assets/image/计算机组成原理/指令系统/隐含寻址.jpg)

如 8086：  
MUL 指令 ： 被乘数隐含在 AX（16位）或 AL（8位）中  
MOVS 指令 ： 源操作数的地址隐含在 SI 中；目的操作数的地址隐含在 DI 中

- 由于隐含寻址在指令字中少地址,因此,这种寻址方式的指令有利于缩短指令字长

#### **四、间接寻址**

指令字中的形式地址不直接指出操作数的地址,而是指出操作数有效地址所在的存储单元地址,也就是说,有效地址是由形式地址间接提供的,故为间接寻址。即EA=(A)

**1.一次间址**

![一次间址](/assets/image/计算机组成原理/指令系统/一次间址.jpg)


**2.多次间址**

![多次间址](/assets/image/计算机组成原理/指令系统/多次间址.jpg)

- 执行指令阶段2次访存
- 可扩大寻址范围
- 便于编制程序

#### **五、寄存器寻址**

在寄存器寻址的指令字中,地址码字段直接指出了寄存器的编号。即$EA=R_{i}$

![寄存器寻址](/assets/image/计算机组成原理/指令系统/寄存器寻址.jpg)

- 执行阶段不访存，只访问寄存器，执行速度快
- 寄存器个数有限，可缩短指令字长

#### **六、寄存器间接寻址**

在寄存器间接寻址的指令字中,操作数的地址存放在寄存器中。即$EA=(R_{i})$

![寄存器间接寻址](/assets/image/计算机组成原理/指令系统/寄存器间接寻址.jpg)

- 有效地址在寄存器中， 操作数在存储器中，执行阶段访存
- 便于编制循环程序

#### **七、基址寻址**

**1.采用专用寄存器作基址寄存器**

基址寻址需设有基址寄存器BR,其操作数的有效地址EA等于指令字中的形式地址与基址寄存器中的内容(称作基地址)相加。即EA=A+(BR)

![基址寻址](/assets/image/计算机组成原理/指令系统/基址寻址.jpg)

- 可扩大寻址范围 
- 有利于多道程序 
- BR 内容由操作系统或管理程序确定
- 在程序的执行过程中 BR 内容不变，形式地址 A 可变

**2.采用通用寄存器作基址寄存器**

![采用通用寄存器作基址寄存器](/assets/image/计算机组成原理/指令系统/采用通用寄存器作基址寄存器.jpg)

- 由用户指定哪个通用寄存器作为基址寄存器
- 基址寄存器的内容由操作系统确定，用户不能改变
- 在程序的执行过程中 R0  内容不变，形式地址 A 可变

**八、变址寻址**

变址寻址与基址寻址极为相似。其有效地址EA等于指令字中的形式地址A与变址寄存器ⅨX的内容相加之和。即EA=A+(IX)

![变址寻址](/assets/image/计算机组成原理/指令系统/变址寻址.jpg)

- 可扩大寻址范围
- IX 的内容由用户给定
- 在程序的执行过程中 IX 内容可变，形式地址 A 不变
- 便于处理数组问题

**九、相对寻址**

相对导址的有效地址是将程序计数器PC的内容(即当前指令的地址)与指令字中的形式地址A相加而成。即EA=(PC)+A。A 是相对于当前指令的位移量（可正可负，补码）

![相对寻址](/assets/image/计算机组成原理/指令系统/相对寻址.jpg)

- A 的位数决定操作数的寻址范围 
- 程序浮动(程序在内存中存储位置发生变化)
- 广泛用于转移指令

**十、堆栈寻址**

![堆栈寻址](/assets/image/计算机组成原理/指令系统/堆栈寻址.jpg)

SP的修改与主存编址方法有关  
![SP的修改](/assets/image/计算机组成原理/指令系统/SP的修改.jpg)


## 6.4 指令格式举例

### 6.4.1 设计指令格式时应考虑的各种因素

1. 指令系统的 兼容性 
2. 其他因素  
操作类型:包括指令个数及操作的难易程度  
数据类型:确定哪些数据类型可参与操作  
指令格式:指令字长是否固定,操作码位数、是否采用扩展操作码技术，地址码位数、地址个数、寻址方式类型  
寻址方式:指令寻址、操作数寻址   
寄存器个数:寄存器的多少直接影响指令的执行时间

