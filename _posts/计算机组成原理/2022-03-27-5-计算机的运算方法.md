---
redirect_from: /_posts/2022-03-27-5-计算机的运算方法.md
title: 第五章 计算机的运算方法
tags: 计算机组成原理
---

## 5.1 无符号数和有符号数

> 计算机中的数均放在寄存器中,通常称寄存器的位数为机器字长。所谓无符号数即没有符号的数,在寄存器中的每一位均可用来存放数值。当存放有符号数时,则需留出位置存放“符号”。

### 5.1.1 无符号数

**寄存器的位数反映无符号数的表示范围**

![无符号数](/assets/image/计算机组成原理/计算机的运算方法/无符号数.jpg)

### 5.1.2 有符号数

> 对有符号数而言,符号的“正”、“负”机器是无法识别的,但由于“正”“负”恰好是两种截然不同的状态,如果用“0”表示“正”,用“1”表示“负”这样符号也被数字化了,并且规定将它放在有效数字的前面,这样就组成了有符号数。

#### **一、机器数与真值**

- 机器数:符号“数字化”的数
- 真值:带“+”或“-”符号的数

![机器数与真值](/assets/image/计算机组成原理/计算机的运算方法/机器数与真值.jpg)

> 注：没有任何硬件表示小数点的位置，计算机中的小数点都以约定方式给出。小数定点器：小数点在符号位后面或整数定点器：小数点在数值位后面

#### **二、原码**

> 原码是机器数中最简单的一种表示形式,其符号位为0表示正数,符号位为1表示负数,数值位即真值的绝对值,故原码表示又称作带符号的绝对值表示。

为了书写方便以及区别整数和小数,约定整数的符号位与数值位之间用逗号“,”隔开;小数的符号位与数值位之间用小数点“.”隔开，计算机中没有。如上画四个数的原码分别是0.1011、1.1011、0,1100和1,1100。

- **整数的原码**

![整数的原码](/assets/image/计算机组成原理/计算机的运算方法/整数的原码.jpg)

- **小数的原码**

![小数的原码](/assets/image/计算机组成原理/计算机的运算方法/小数的原码.jpg)


#### **三、补码**

> 原码表示简单明了,并易于和真值转换。但用原码进行加减运算时，当两个数符号相同时做加法操作，当两个数符号不同时实际上做的是减法操作，比较麻烦。  

> 那么能否在计算机中只设加法器,只作加法操作呢?如果能找到个与负数等价的正数来代替该负数,就可把减法操作用加法代替。而机器数采用补码时就能满足此要求。

- **正数的补码是它本身**
- **负数的补码是符号位不变，每位取反再加1**

![时钟补码](/assets/image/计算机组成原理/计算机的运算方法/时钟补码.jpg)

以时钟为例，比如说当前在6点位置，我们想把时钟拨到3点位置，可以顺时针拨9个小时即+9，也可以逆时针拨3个小时即-3，因此在这里可以用(6+9)%12代替6-3，这就使用了加法代替了减法

由上图可知：  
-  一个负数加上 “模” 即得该负数的补数`-3+12=9`
- 一个正数和一个负数互为补数时，它们绝对值之和即为模的大小`|-3|+|9|=12`

由此可以推出二进制的补码  

![补码1](/assets/image/计算机组成原理/计算机的运算方法/补码1.jpg)

仍然存在以下一个问题，一个负数的补码是一个正数，正数的补码是它本身，那么负数的补码和正数的补码就可能相等。
如下所示，-1011的补码是+0101，+0101的补码仍然是+0101

![补码2](/assets/image/计算机组成原理/计算机的运算方法/补码2.jpg)

那么怎么区分得到的这个补码是正数的补码还是负数的补码呢？  

模仿原码的表示方法，我们在正数的补码前加一个`0，`，如`0,0101`表示+0101的补码；在负数的补码前加一个`1，`，如`1，0101`表示-1011的补码

那么怎么实现在符号位部分给正数的补码添一个0，给负数的补码添一个1呢？  

答案就是以$2^{n+1}$为模。例如，`-1011+10000->0101`,`0101+10000->10101`。此时n=4，以$2^{n+1}$为模则要再加一个$2^{n}$，`1011+10000->0101,0101+10000->10101`,`0101+10000->10101`。此时n=4，以$2^{n+1}$为模则要再加一个$2^{n}$，`1011+10000->0101,0101+10000->10101`,`0101+10000->10101`。此时n=4，以$2^{n+1}$为模则要再加一个$2^{n}$，`1011+10000->0101,0101+10000->1,0101`,`0101+10000->10101,10101+10000->0,0101`

![补码3](/assets/image/计算机组成原理/计算机的运算方法/补码3.jpg)

**然后给出补码的定义：**  

整数的补码：  

![整数的补码](/assets/image/计算机组成原理/计算机的运算方法/整数的补码.jpg)

小数的补码：

![小数的补码](/assets/image/计算机组成原理/计算机的运算方法/小数的补码.jpg)

上面我们提到了负数的补码等于符号位不变，每位取反在加一，怎么来的呢？

![补码快捷计算](/assets/image/计算机组成原理/计算机的运算方法/补码快捷计算.jpg)

以上是原码求补码，补码求原码也是符号位不变，每位取反在加一。

#### **四、反码**

- **正数反码是它本身**
- **负数反码符号位不变，其余按位取反**

**整数的反码**

![整数反码](/assets/image/计算机组成原理/计算机的运算方法/整数的反码.jpg)

**小数的反码**

![小数反码](/assets/image/计算机组成原理/计算机的运算方法/小数的反码.jpg)

#### **五、移码**

> 当真值用补码表示时,由于符号位和数值部分起编码,与习惯上的表示法不同,因此人们很难从补码的形式上直接判断其真值的大小

移码就是在真值上加一个常数$2^{n}$。在数轴上移码所表示的范围恰好对应与真值在数轴上的范围向轴的正方向移动2"个单元。

![移码](/assets/image/计算机组成原理/计算机的运算方法/移码.jpg)

**补码和移码的区别**

- 补码中符号位0表示正数的补码，1表示负数的补码，移码中符号位1表示正数的移码，0表示负数的移码  
- 一个数的补码和移码只有符号位不同，其余位完全相同，将符号位取反可完成移码和补码的相互转换

**移码的特点**

![移码的特点](/assets/image/计算机组成原理/计算机的运算方法/移码的特点.jpg)

## 5.2 数的定点表示和浮点表示

### 5.2.1 定点表示

![定点表示](/assets/image/计算机组成原理/计算机的运算方法/定点表示.jpg)

### 5.2.2 浮点表示

#### **一、浮点数的表示形式**

![浮点数表示](/assets/image/计算机组成原理/计算机的运算方法/浮点数表示.jpg)

为了提高数据精度以及便于浮点数的比较,在计算机中规定浮点数的尾数用纯小数形式,故上例中$0.110101×2^{10}$和$0.00110101×2^{10}$形式是可以采用的。此外,将尾数最高位为1的浮点数称作规格化数,即$0.110101×2^{10}$为浮点数的规格化形式。浮点数表示成规格化形式后,其精度最高。

**浮点数在在计算机中的表示**

![浮点数在在计算机中的表示](/assets/image/计算机组成原理/计算机的运算方法/浮点数在在计算机中的表示.jpg)

#### **二、浮点数的取值范围**

![浮点数的表示范围](/assets/image/计算机组成原理/计算机的运算方法/浮点数的表示范围.jpg)

#### **三、浮点数的规格化形式**

![浮点数的规格化形式](/assets/image/计算机组成原理/计算机的运算方法/浮点数的规格化形式.jpg)

#### **四、浮点数的规格化**

- **浮点数的规格化**

![浮点数规格化](/assets/image/计算机组成原理/计算机的运算方法/浮点数的规格化形式.jpg)

- **零的表示**

![零的表示](/assets/image/计算机组成原理/计算机的运算方法/机器零的表示.jpg)

- **IEEE 754  标准**

![IEEE754标准](/assets/image/计算机组成原理/计算机的运算方法/IEEE754标准.jpg)

## 5.3 定点运算

### 5.3.1 移位运算

> 移位运算又叫移位操作,对计算机来说,有很大的实用价值。例如,当某计算机没有乘(除)法运算线路时,可以采用移位和加法相结合,实现乘(除)运算。

**`移位：小数点不动，数据相对于小数点移动几位。在计算机中，移位与加减配合，能够实现乘除运算。`**

#### **一、算术移位**

**`算术移位：对有符号数的移位。符号位保持不变，对移位产生的空位填0或填1`**

**`所有的反码、补码结果转换成原码后都应和原来的原码移位结果相同。`**

![算术移位规则](/assets/image/计算机组成原理/计算机的运算方法/算术移位规则.jpg)


- 正数的移位
    - 正数的原码、反码、补码相同，所以其中的0和1意义相同，所以对于正数的反码或补码移位产生的空位都应填0
- 负数的移位
    - 对于原码来说，无论左移或右移都应对空位填0。
    - 对于反码来说，除符号位反码的每位都与原码相反，在反码中0对应原码的1，1对应原码的0，所以对反码的移位空位应填1。
    - 对于补码来说分为左移和右移。将补码分为两个部分，左移填0，右移填1。

#### **二、逻辑移位**

**`逻辑移位：无符号移位`**

- 逻辑左移：低位添0，高位丢掉
- 逻辑右移：高位添0，低位丢掉

### 5.3.2 加减法运算

#### **一、补码加法运算公式**

(1) 加法  

$$\begin{split}整数\quad [A]\_{补} + [B]\_{补} = [A+B]\_{补}(mod\enspace2^{n+1})\\
小数\quad [A]\_{补} + [B]\_{补} = [A+B]\_{补}(mod\enspace2)
\end{split}$$

(2) 减法
$$\begin{split} 
整数\quad \[A-B]_\{补} = \[A+(-B)]\_{补} = [A]\_{补} + [-B]\_{补}(mod\enspace2^{n+1})\\
小数\quad [A-B]\_{补} = [A+(-B)]\_{补} = [A]\_{补} + [-B]\_{补}(mod\enspace2)  
\end{split}$$

**连同符号位一起相加，符号位产生的进位自然丢掉**

#### **二、溢出判断**

溢出：运算的结果超出了机器字长所能表示的范围。由于减法运算在机器中是用加法器实现的,因此可得出如下结论:不论是作加法还是减法,只要实际参加操作的两个数(减法时即为被减数和“求补以后的减数)符号相同,结果又与原操作数的符号不同,即为溢出。

- 对于加法,只有在正数加正数和负数加负数两种情况下才可能出现溢出,符号不同的两个数相加是不会出现溢出的。
- 对于减法,只有在正数减负数或负数减正数两种情况下才可能出现溢出,符号相同的两个数相减是不会出现溢出的。

**(1) 用一位符号位判断**

计算机中采用一位符号位判断时,为了节省时间,通常用符号位产生的进位与最高有效位产生的进位异或操作后,按其结果进行判断。若异或结果为1,即为溢出;异或结果为0,则无溢出。

**(2) 用两位符号位判断**

用两位符号位判断采用两位符号位的补码，即变形补码,以4为模

![两位符号位小数补码](/assets/image/计算机组成原理/计算机的运算方法/两位符号位小数补码.jpg)

![两位符号位整数补码](/assets/image/计算机组成原理/计算机的运算方法/两位符号位整数补码.jpg)

在用变形补码作加法时,两位符号位要连同数值部分一起参加运算,而且高位符号位产生的进位自动丢失,便可得正确结果。即

$$\begin{split}
[A]\_{补} + [B]\_{补} = [A+B]\_{补}(mod\enspace4)\\
\[A-B]_\{补} = \[A+(-B)]\_{补} = [A]\_{补} + [-B]\_{补}(mod\enspace 4)$$
\end{split}$$

变形补码判断溢出的原则是:当两位符号位不同时,表示溢出,否则无溢出。不论是否发生溢出,高位(第一位)符号位水远代表真正的符号。

**(3)补码定点加减法的硬件配置**

![补码定点加减法的硬件配置](/assets/image/计算机组成原理/计算机的运算方法/补码定点加减法的硬件配置.jpg)

图中寄存器A、X、加法器的位数相等,其中A存放被加数(或被减数的补码,Ⅹ存放加数(或减数)的补码。当作减法时,由“求补控制逻辑”将送全加法器,并使加法器的最末位外来进位为1,以达到对减数求补的目的运算结果溢出时,通过溢出判断电路置“1”溢出标记V。$G_{A}$为加法标记,$G_{S}$为减法标记。

### 5.3.3 乘法运算

### 5.3.4 除法运算

## 5.4 浮点四则运算
## 5.5 算术逻辑单元
