---
redirect_from: /_posts/2021-11-25-1-设计模式的七大原则.md
title: 设计模式的七大原则
tags: 设计模式
---

## 开闭原则（Open Close Principle）
> 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。

## 单一职责原则（Single Responsibility Principle，SRP）
> 单一职责原则又称单一功能原则，这里的职责是指类变化的原因，单一职责原则规定一个类应该**有且仅有一个**引起它变化的原因，否则类应该被拆分。
> 该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：
> - 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；
> - 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费

一个类只负责一个职责，单一职责同样也适用于方法。一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用。  
由于开发的时候职责的界定并不明确，可能一开始的设计是符合单一职责原则的，当职责扩散(职责扩散，就是因为某种原因，职责P被分化为粒度更细的职责P1和P2)时，原有代码便不符合单一职责原则

用一个类描述交通工具的运动

```java
class Vehicle{
    public void run(String vehicle){
        System.out.println(vehicle + "在运动");
    }
}
```
>运行结果:  
> 摩托车在在运动
> 汽车在在运动  
> 轮船在运动  
> 飞机在运动

这样在以上要求看来没什么问题，但如果需求变化，需要描述出交通工具的运动地点（水、陆、空），上面代码就不符合单一职责原则了。
```java
// 不符合单一职责原则
class Vehicle{
    public void run(String vehicle){
        System.out.println(vehicle + "在路上运动");
    }
}
```
>运行结果:  
> 摩托车在路上运动  
> 汽车在路上运动  
> 轮船在路上运动  
> 飞机在路上运动

如果按照单一职责原则，需要将交通工具类修改成路上、水上、空中交通工具类。
```java
class Vehicle{
    public void run(String vehicle){
        System.out.println(vehicle + "在路上运动");
    }
}

class VehicleWater{
    public void run(String vehicle){
        System.out.println(vehicle + "在水上运动");
    }
}

class VehicleAir{
    public void run(String vehicle){
        System.out.println(vehicle + "在空中运动");
    }
}
```
>运行结果:  
> 摩托车在路上运动   
> 汽车在路上运动  
> 轮船在水上运动  
> 飞机在空中运动

如果需求再发生变化，要求将在水上运动划分为在海上运动和在淡水湖上运动，此时需要再加上一个交通工具类，但如果需求越来越多，那么修改的花销就会越来越大。  
如果直接再原来的类上修改，虽然会减少花销，但又违反了单一职责原则。

```java
class Vehicle{
// 不符合单一职责原则
    public void run(String vehicle){
        if ("摩托车".equals(vehicle)){
            System.out.println(vehicle + "在路上运动");
        }else if("轮船".equals(vehicle)){
            System.out.println(vehicle + "在水上运动");
        }else if("飞机".equals(vehicle)){
            System.out.println(vehicle + "在空中运动");
        }
    }
}
```

此时可以采用另一种修改方式

```java
class Vehicle{
    public void run(String vehicle){
        System.out.println(vehicle + "在路上运动");
    }
    
    public void runAir(String vehicle){
        System.out.println(vehicle + "在空中运动");
    }

    public void runWater(String vehicle){
        System.out.println(vehicle + "在水上运动");
    }

    /**
    public void runWater1(String vehicle){
        System.out.println(vehicle + "在海上运动");
    }

    public void runWater2(String vehicle){
        System.out.println(vehicle + "在淡水湖上运动");
    }
    **/
}
```

这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然也违背了类的单一职责原则，但在方法级别上却是符合单一职责原则的，因为它并没有动原来方法的代码。

## 接口隔离原则（Interface Segregation Principle）
> 接口隔离原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

## 依赖倒置原则（Dependence Inversion Principle）
> 依赖倒置原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

面向接口编程，而不是面向实现类编程

## 里氏替换原则（Liskov Substitution Principle）
> 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

任何父类所在的地方都可以由其子类替换

## 迪米特法则（Demeter Principle）
> 迪米特法则，又称最少知道原则，是指一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

## 合成复用原则（Composite Reuse Principle）
> 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。