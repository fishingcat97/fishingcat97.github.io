---
redirect_from: /_posts/2022-07-18-2-操作系统基础操作.md
title: 第二章 操作系统基础操作
tags: 操作系统
---

## 2.1 X86-32硬件

### 2.1.1 X86-32硬件-运行模式

80386机器有四种运行模式：
- 实模式
  - 有16位寻址空间且没有保护机制
  - 80386加电启动后处于实模式运行状态,在这种状态下软件可访问的物理内存空间不能超过1MB,且无法发挥intel 80386以上级别的32位CPU的4GB内存管理能力
- 保护模式
  - 有32位寻址空间且有强大的保护机制确保操作系统的安全以及跑的各个程序之间的安全性。
  - 支持内存分页机制,提供了对虚拟内存的良好支持。保护模式下80386支持多任务,还支持优先级机制,不同的程序可以运行在不同的优先级上。优先级一共分0~3 4个级别,操作系统运行在最高的优先级0上,应用程序则运行在比较低的级别上;配合良好的检查机制后,既可以在任务间实现数据的安全共享也可以很好地隔离各个任务。
- SMM模式
- 8086模式

### 2.1.2 X86-32硬件-内存架构

- 地址是访问内存空间的索引
- 80386是32位的处理器,即可以寻址的物理内存地址空间为$2^{32}=4G$字节
- 物理内存地址空间是处理器提交到总线上用于访问计算机系统中的内存和外设的最终地址。一个计算机系统中只有一个物理地址空间
- 线性地址空间是在操作系统的虚存管理之下毎个运行的应用程序能访问的地址空间。每个运行的应用程序都认为自己独享整个计算机系统的地址空间,这样可让多个运行的应用程序之间相互隔离
- 逻辑地址空间是应用程序直接使用的地址空间

```
段机制启动、页机制未启动:逻辑地址->段机制处理->线性地址=物理地址
段机制和页机制都启动:逻辑地址->段机制处理->线性地址->页机制处理->物理地址
```

### 2.1.3 X86-32硬件-寄存器

- 通用寄存器
  - EAX:累加器
  - EBX:基址寄存器
  - ECX:计数器
  - EDX:数据寄存器
  - EAI:源地址指针寄存器
  - EDI:目的地址指针寄存器
  - EBP:基址指针寄存器
  - ESP:堆栈指针寄存器
- 段寄存器
  - CS:代码段( Code Segment)
  - DS:数据段( Data Segment)
  - ES:附加数据段( Extra Segment)
  - SS:堆栈段( Stack Segment)
  - FS:附加段
  - GS:附加段
- 指令指针寄存器
  - EIP:指令寄存器EIP的低16位就是8086的IP,它存储的是下一条要执行指令的内存地址,在分段地址转换中,表示指令的段内偏移地址。
- 标志寄存器
  - IF( Interrupt Flag):中断允许标志位由CLI,STI两条指令来控制;设置IF使CPU可识别外部(可屏蔽)中断请求。复位IF则禁止中断。IF对不可屏蔽外部中断和故障中断的识别没有任何作用。
- 控制寄存器
- 系统地址寄存器,调试寄存器,测试寄存器

## 2.2 操作系统的启动

**前置说明**
- CPU, I/O, 内存通过总线连接
- DISK:存放OS
- BIOS：基本I/O处理系统( basic I/O system)
- Bootloader: 加载OS到内存中
![](/assets/image/操作系统/操作系统基础操作/内存和DISK.png)


**开机启动流程**

1. 当电脑通电时，段寄存器CS和指令指针寄存器IP能够确定一个具体的内存地址，例如CS:IP = 0xf000:fff0，系统处于实模式，PC=16*CS+IP，加电后BIOS从这个地址开始执行。此时只有20地址可用，可用区域$2^{20}=1MB$。
2. POST(加电自检)，寻找显卡和执行BIOS。(显示器，键盘…是否正常)。
3. BIOS
   - 将Bootloader从磁盘的引导扇区加载到内存的0x7C00，连续向上512B (Bootloader一般放在第一个硬盘的第一个主引导扇区，一共占用512个字节的内存)
   - 跳转到 CS : IP = 0x0000 : 0x7C00
4. Bootloader
   - 将操作系统的代码和数据从硬盘加载到内存中
   - 跳转到操作系统的起始地址

![](/assets/image/操作系统/操作系统基础操作/系统启动.png)

**具体流程**

1. CPU初始化
   1. CPU加电稳定后从0xffff0读第一条指令
      -  CS:IP = 0xf000:fff0
      -  第一条指令是跳转指令
   2. CPU初始状态是16位实模式
      - CS:IP是16位寄存器
      - PC=16*CS+IP=0xffff0
      - 最大地址空间是1MB
2. BIOS初始化
   1. 硬件自检POST
   2. 检测系统中内存和显卡等关键部件的存在和工作状态
   3. 查找并执行显卡等接口卡BIOS，进行设备初始化
   4. 执行系统BIOS，进行系统检测
      - 检测和配置系统中安装的即插即用设备
   5. 更新CMOS中的扩展系统配置数据（ESCD）
   6. 按指定顺序从软盘、影盘或光驱启动
3. 主引导记录MBR格式
   1. 启动代码：446字节
      - 检查分区表正确性
      - 加载并跳转到磁盘上的引导程序（Bootloader）
   2. 硬盘分区表：64字节
      - 描述分区状态和位置
      - 每个分区描述信息占16字节
   3. 结束标志字：2字节（结束标志55AA）
      - 主引导记录有效的标志
4. 分区引导扇区格式
   1. 跳转指令：跳转到启动代码（OS）
      - 与平台相关代码
   2. 文件卷头：文件系统描述信息
   3. 启动代码：跳转到加载程序
   4. 结束标志：55AA
5. 加载程序
   1. 从文件系统中读取启动配置信息
   2. 可选的操作系统内核列表和加载参数，如：正常启动、安全模式启动、调试状态启动等
   3. 依据配置加载指定内核并跳转到内核执行
      
## 2.3 中断、异常、系统调用

### 2.3.1 中断

> 中断来源于外设，来自不同的硬件设备的处理请求

**中断流程**

- 硬件处理：在CPU初始化时设置中断使能标志
  - 依据内部或外部事件设置中断标志
  - 依据中断向量调用相应中断服务例程
- 软件
  - 保存现场（编译器）
  - 中断服务处理（服务例程）
  - 清除中断标记（服务例程）
  - 恢复现场（编译器）
  

### 2.3.2 异常

> 非法指令或其它原因导致当前指令执行失败(e.g.内存出错)后的处理请求

**异常处理流程**

- 保存现场
- 异常处理
  - 杀死了产生异常的程序
  - 重新执行异常指令
- 恢复现场

### 2.3.3 系统调用

> 应用程序主动向操作系统发出服务请求

### 2.3.4 中断、异常、系统调用区别和特点

|  类型 | 源头 | 处理时间 | 响应 |
|  ----  | ----  |  ----  | ----  |
| 中断|外设| 异步 | 持续，对应用程序透明，用户不会产生中断感觉 |
| 异常  | 应用程序意向不到的行为 | 同步 | 杀死或重新执行指令 |
|系统调用 | 应用程序请求系统提供服务 | 同步或异步 | 等待和持续，等待服务执行结束后继续向下执行，不会重复执行 |

**为什么应用程序不能直接访问外设而是通过操作系统？**

- 在计算机运行时，内核是被信任的第三方
- 只有内核可以执行特权指令
- 为了方便应用程序，通过操作系统给上层应用提供接口，使上层应用不用关注设备的不同细节，通过操作系统屏蔽设备的复杂性和差异性，使上层应用通用、可移植