---
redirect_from: /_posts/2022-07-20-3-物理内存管理.md
title: 第三章 物理内存管理
tags: 操作系统
---

## 3.1 计算机体系结构和内存层次

**计算机体系结构**

![](/assets/image/操作系统/物理内存管理/计算机体系结构.png)

**内存层次**

![](/assets/image/操作系统/物理内存管理/内存层次.png)

**操作系统的内存管理**


![](/assets/image/操作系统/物理内存管理/操作系统的内存管理.png)

存储管理的目标：

- 抽象：逻辑地址空间。把线性物理地址编号转变成抽象的逻辑地址空间
- 保护：独立地址空间。对地址空间进行保护，每个进程只能访问自己的空间，尽管他们在内存中是相邻存放
- 共享：访问相同内存
- 虚拟：更多的地址空间

**内存管理方法**

- 程序重定位
- 分段
- 分页
- 虚拟内存
- 按需分页虚拟内存

> 实现高度依赖于硬件, 其中内存管理单元(MMU)负责处理CPU的内存访问请求

## 3.2 地址空间和地址生成

**地址空间定义**

- 物理地址空间：硬件支持的地址空间( address : [0, Max_sys] )
- 逻辑地址空间：一个运行的程序所拥有的的内存范围( address : [0, Max_prog] )

**地址生成时机和限制**

- 编译时
  - 假设起始地址已知
  - 如果起始地址改变，必须重新编译
- 加载时
  - 如果编译时起始地址未知，编译器需生成可重定位的代码
  - 加载时生成绝对地址
- 执行时
  - 执行时代码可移动
  - 需地址转换（映射）硬件支持

## 3.3 连续式内存分配

> 连续内存分配：给进程分配一块不小于指定大小的连续的物理内存区域

**内存碎片**

> 内存碎片问题指的是空闲的内存无法被利用

- 外部碎片 : 分配单元间的未使用内存
- 内部碎片 : 分配单元内的未使用内存

### 3.3.1 动态分区分配

- 动态分区分配:
  - 当程序被加载执行时,分配一个进程指定大小可变的分区(块、内存块)
  - 分区的地址是连续的
- 操作系统需要维护的数据结构
  - 所有进程的已分配分区
  - 空闲分区( Empty- blocks)

**动态分区分配方式**
1. 最先匹配(First-fit) : 在空闲内存中找到第一个比需求大的空闲块, 分配给应用程序
   - 原理&实现
      1. 空闲分区列表按**地址顺序**排列
      2. 搜索第一个合适的分区
      3. 释放分区时，检查是否可与临近的空闲分区合并
   - 优点
      - 实现简单
      -  在高地址空间有大块的空闲分区
   - 缺点
     - 产生外部碎片
     - 不确定性
2. 最佳匹配(Best-fit): 在空闲内存中找到比需求内存大的空闲块中的最小空闲块, 分配给应用程序
   - 原理&实现
      1. 空闲分区列表按**空间从小往大**排列
      2. 分配需要寻找一个合适的分区
      3. 释放时，查找并合并到相邻空闲分区(如果有)
   - 优点
      - 实现简单
      - 对小分区空间需求较多时高效
      - 避免大空闲分区被拆分
      - 可减小外部碎片大小
   - 缺点
     - 产生外部碎片
     - 释放分区较慢
     - 容易产生很多无用的小碎片
3. 最差匹配(Worst-fit): 在空闲内存中找到最大的空闲块, 分配给应用程序
   - 原理&实现
      1. 空闲分区列表按**空间由大到小**顺序排列
      2. 分配时，选最大的分区
      3. 释放时,检查是否可与临近的空闲分区合并,进行可能的合并,并调整空闲分区列表顺序
   - 优点
      - 对中等大小空间分区需求较多时，效果较好
      - 避免出现太多的小碎片
   - 缺点
     - 释放分区较慢
     - 产生外部碎片
     - 容易破坏大的空闲分区,因此后续难以分配大的分区

 ### 3.3.2 碎片整理

 

## 3.4 非连续式内存分配

