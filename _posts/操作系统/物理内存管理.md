---
redirect_from: /_posts/2022-07-20-3-物理内存管理.md
title: 第三章 物理内存管理
tags: 操作系统
---

## 3.1 计算机体系结构和内存层次

**计算机体系结构**

![](/assets/image/操作系统/物理内存管理/计算机体系结构.png)

**内存层次**

![](/assets/image/操作系统/物理内存管理/内存层次.png)

**操作系统的内存管理**


![](/assets/image/操作系统/物理内存管理/操作系统的内存管理.png)

存储管理的目标：

- 抽象：逻辑地址空间。把线性物理地址编号转变成抽象的逻辑地址空间
- 保护：独立地址空间。对地址空间进行保护，每个进程只能访问自己的空间，尽管他们在内存中是相邻存放
- 共享：访问相同内存
- 虚拟：更多的地址空间

**内存管理方法**

- 程序重定位
- 分段
- 分页
- 虚拟内存
- 按需分页虚拟内存

> 实现高度依赖于硬件, 其中内存管理单元(MMU)负责处理CPU的内存访问请求

## 3.2 地址空间和地址生成

**地址空间定义**

- 物理地址空间：硬件支持的地址空间( address : [0, Max_sys] )
- 逻辑地址空间：一个运行的程序所拥有的的内存范围( address : [0, Max_prog] )

**地址生成时机和限制**

- 编译时
  - 假设起始地址已知
  - 如果起始地址改变，必须重新编译
- 加载时
  - 如果编译时起始地址未知，编译器需生成可重定位的代码
  - 加载时生成绝对地址
- 执行时
  - 执行时代码可移动
  - 需地址转换（映射）硬件支持

## 3.3 连续式内存分配

> 连续内存分配：给进程分配一块不小于指定大小的连续的物理内存区域

**内存碎片**

> 内存碎片问题指的是空闲的内存无法被利用

- 外部碎片 : 分配单元间的未使用内存
- 内部碎片 : 分配单元内的未使用内存

### 3.3.1 动态分区分配

- 动态分区分配:
  - 当程序被加载执行时,分配一个进程指定大小可变的分区(块、内存块)
  - 分区的地址是连续的
- 操作系统需要维护的数据结构
  - 所有进程的已分配分区
  - 空闲分区( Empty- blocks)

**动态分区分配方式**
1. 最先匹配(First-fit) : 在空闲内存中找到第一个比需求大的空闲块, 分配给应用程序
   - 原理&实现
      1. 空闲分区列表按**地址顺序**排列
      2. 搜索第一个合适的分区
      3. 释放分区时，检查是否可与临近的空闲分区合并
   - 优点
      - 实现简单
      -  在高地址空间有大块的空闲分区
   - 缺点
     - 产生外部碎片
     - 不确定性
2. 最佳匹配(Best-fit): 在空闲内存中找到比需求内存大的空闲块中的最小空闲块, 分配给应用程序
   - 原理&实现
      1. 空闲分区列表按**空间从小往大**排列
      2. 分配需要寻找一个合适的分区
      3. 释放时，查找并合并到相邻空闲分区(如果有)
   - 优点
      - 实现简单
      - 对小分区空间需求较多时高效
      - 避免大空闲分区被拆分
      - 可减小外部碎片大小
   - 缺点
     - 产生外部碎片
     - 释放分区较慢
     - 容易产生很多无用的小碎片
3. 最差匹配(Worst-fit): 在空闲内存中找到最大的空闲块, 分配给应用程序
   - 原理&实现
      1. 空闲分区列表按**空间由大到小**顺序排列
      2. 分配时，选最大的分区
      3. 释放时,检查是否可与临近的空闲分区合并,进行可能的合并,并调整空闲分区列表顺序
   - 优点
      - 对中等大小空间分区需求较多时，效果较好
      - 避免出现太多的小碎片
   - 缺点
     - 释放分区较慢
     - 产生外部碎片
     - 容易破坏大的空闲分区,因此后续难以分配大的分区

### 3.3.2 碎片整理

> 通过调整进程占用的分区位置来减少或避免分区碎片

**压缩式碎片整理**

> 通过移动分配给进程的内存分区,以合并外部碎片

- 压缩式碎片整理的条件
  - 所有的应用程序可动态重定位
- 何时重置
  - 在程序处于等待状态时才可以重置
  - 需要考虑内存拷贝的开销

**交换式碎片整理**

> 通过抢占并回收处于等待状态进程的分区,以增大可用内存空间

此时存在三个进程P1、P2、P3。P1处于等待状态；P2处于运行状态；P3处于就绪状态。三个进程在内存里占据了一定的内存空间。

![](/assets/image/操作系统/物理内存管理/碎片整理分区对换1.png)

当此时要运行一个所需内存空间大于内存空余空间的进程P4时，可以将处于等待状态的进程P1信息移入外存，将进行P1所占的内存空间分配给进程P4。

![](/assets/image/操作系统/物理内存管理/碎片整理分区对换2.png)

**例：伙伴系统**

- 整个可分配的分区大小$2^{U}$
- 需要的分区大小为$2^{U-1}<s≤2^{U}$时,把整个块分配给该进程
- 如$s≤2^{i-1}$,将大小为$2^{i}$的当前空闲分区划分成两个大小为$2^{i-1}$的空闲分区
- 重复划分过程,直到$2^{i-1}<s≤2^{i}$,并把一个空闲分区分配给该进程

- 释放过程
  - 把释放的块放入空闲块数组
  - 合并满足合并条件的空闲块
- 合并条件
  - 大小相同$2^{i}$
  - 地址相邻
  - 起始地址较小的块的起始地址必须是$2^{i+1}$的倍数


## 3.4 非连续式内存分配

**连续分配的缺点**
- 分配给程序的物理内存必须连续
- 存在外碎片和内碎片
- 内存分配的动态修改困难
- 内存利用率较低

**非连续分配的优点**
- 提高内存利用效率和管理灵活性
- 允许一个程序的使用非连续的物理地址空间
- 允许共享代码与数据
- 支持动态加载和动态链接

### 3.4.1 段式存储管理

- 段表示访问方式和存储数据等属性相同的一段地址空间
- 对应一个连续的内存“块
- 若干个段组成进程逻辑地址空间

![](/assets/image/操作系统/物理内存管理/段地址空间.png)

**分段寻址方案**

- 逻辑地址由二元组(s,addr)表示
- s——段号
- addr——段内偏移

![](/assets/image/操作系统/物理内存管理/段基址+段内偏移.png)

寻址过程

1. 先找到存储单元的逻辑地址，由段号和段内偏移组成
2. 根据段号查找段表获得物理地址中的起始地址以及长度限制，段表(段号, 物理地址中的起始地址, 长度限制)
3. 由MMU对比段内偏移和限制长度。 段内偏移 ≤ 限制长度 ？ 物理地址=段表中的起始地址 + 二元组中的偏移地址 ： 内存异常

![](/assets/image/操作系统/物理内存管理/段访问的硬件实现.png)

**物理地址=段表中的起始地址 + 二元组中的偏移地址**

### 3.4.2 页式存储管理

- 页帧(帧、物理页面, Frame, Page Frame)
  - 把物理地址空间划分为大小相同的基本分配单位
  - 2的n次方,如512,4096,8192
- 页面(页、逻辑页面,Page)
  - 把逻辑地址空间也划分为相同大小的基本分配单位
  - 帧和页的大小必须是相同的
- 页面到页帧：逻辑地址到物理地址的转换
  - 页表：保存转换关系
  - 存储管理单元(MMU)/快表(TLB)

**帧(Frame)**

内存物理地址的表示:二元组(f,o)
- f——帧号(F位,共有$2^{F}$个帧)
- o——帧内偏移(S位,每帧有$2^{S}$字节)
- $物理地址=f*2^{S}+o$

![](/assets/image/操作系统/物理内存管理/帧的物理地址.png)

例子 : 16-bit地址空间, 9-bit(512 byte) 大小的页帧
- F=7,S=9,f=3,o=6
- 物理地址 = (f,o) = (3,6) 
- 物理地址 = $2^{9} * 3 + 6 = 1542$

**页(Page)**

- 进程逻辑地址空间被划分为大小相等的页
  - 页内偏移=帧内偏移
  - 通常:页号大小≠帧号大小
- 进程逻辑地址的表示:二元组(p,o)
  - p——页号(P位,$2^{p}$个页)
  - o——页内偏移(S位,每页有$2^{S}$字节)
  - $虚拟地址=p*2^{S}+o$

**页寻址方案**

> 操作系统维护一张页表, 页表保存了逻辑地址——物理地址之间的映射关系

存储 : (页号, 帧号)
- 逻辑地址空间应当大于物理内存空间
- 页映射到帧
- 页是连续的虚拟内存，逻辑地址中的页号是连续的
- 帧是非连续的物理内存(有助于减少碎片的产生)，物理地址中的帧号是不连续的
- 不是所有的页都有对应的帧

### 3.4.3 页表



### 3.4.4 快表和多级页表